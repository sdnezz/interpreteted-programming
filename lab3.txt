from collections import Counter

# === Задача 3 ===
# Задача: найти разницу между частотой наиболее часто встречающегося символа в строке и частотой его появления в заданном алфавите.
# Теория: сравниваем частоты появления символов в конкретном тексте с частотами в языке.
# Алгоритм:
# 1. Считаем частоты символов в тексте.
# 2. Сравниваем с частотами из алфавита.
# 3. Находим абсолютную разницу и сортируем по возрастанию.

def frequency_difference(text, alphabet_freq):
    # Подсчитываем частоту символов в тексте
    text_freq = Counter(text)  # Counter создает словарь частот символов в тексте.
    # Вычисляем разницу между частотами
    differences = {}  # Создаем словарь для хранения разницы частот.
    for char, freq in text_freq.items():
        if char in alphabet_freq:
            # Разница между частотой в тексте и частотой в алфавите
            differences[char] = abs(freq / len(text) - alphabet_freq[char])
    # Сортируем символы по возрастанию разницы
    return sorted(differences.items(), key=lambda x: x[1])

# === Задача 5 ===
# Задача: найти квадратичное отклонение частоты самого часто встречающегося символа в тексте.
# Теория: определяем самый частый символ и считаем, насколько сильно его частота отличается от средней частоты символов.
# Алгоритм:
# 1. Определяем наиболее частый символ.
# 2. Рассчитываем частоту этого символа в тексте.
# 3. Находим квадратичное отклонение этой частоты от среднего значения.

def quadratic_deviation(text):
    text_freq = Counter(text)  # Подсчитываем частоту символов в тексте.
    # Находим самый часто встречаемый символ и его количество
    most_common_char, count = text_freq.most_common(1)[0]  # most_common возвращает список [(символ, частота)].
    # Рассчитываем частоту
    most_common_freq = count / len(text)  # Частота символа в тексте.
    # Средняя частота символов в тексте
    average_freq = 1 / len(set(text))  # Средняя частота символа = 1 / количество уникальных символов.
    # Квадратичное отклонение
    deviation = (most_common_freq - average_freq) ** 2  # Формула для квадратичного отклонения.
    return most_common_char, deviation

# === Задача 8 ===
# Задача: рассчитать квадратичное отклонение разницы в ASCII-кодах зеркально расположенных символов.
# Теория: вычисляем разницу в ASCII-кодах символов и их зеркальных позиций в строке (первый с последним, второй с предпоследним и т.д.)
# Алгоритм:
# 1. Для каждой пары зеркальных символов находим разницу ASCII-кодов.
# 2. Рассчитываем квадратичное отклонение этой разницы.
# 3. Сортируем символы по возрастанию этого значения.

def quadratic_ascii_deviation(text):
    n = len(text)
    deviations = []  # Список для хранения квадратичных отклонений.
    for i in range(n // 2):
        # Рассчитываем разницу в ASCII-кодах между зеркальными символами
        difference = abs(ord(text[i]) - ord(text[-(i + 1)]))  # ord() возвращает ASCII-код символа.
        # Квадратичное отклонение
        deviation = (ord(text[i]) - difference) ** 2
        deviations.append((text[i], deviation))  # Добавляем в список символ и его отклонение.
    # Сортируем по возрастанию отклонений
    return sorted(deviations, key=lambda x: x[1])

# === Задача 9 ===
# Задача: найти квадратичное отклонение дисперсии среднего веса ASCII-кодов троек символов.
# Теория: для каждой тройки символов находим дисперсию и квадратичное отклонение.
# Алгоритм:
# 1. Рассчитываем средний вес троек символов.
# 2. Определяем дисперсию для каждой тройки.
# 3. Сортируем результаты по возрастанию дисперсий.

def ascii_triple_variance(text):
    n = len(text)
    variances = []  # Список для хранения отклонений дисперсий.
    for i in range(n - 2):
        triple = text[i:i+3]  # Извлекаем тройку символов.
        ascii_sum = sum(ord(c) for c in triple)  # Сумма ASCII-кодов тройки.
        mean = ascii_sum / 3  # Средний вес ASCII-кодов.
        # Дисперсия: средний квадрат отклонений от среднего
        variance = sum((ord(c) - mean) ** 2 for c in triple) / 3
        variances.append((triple, variance))
    # Сортируем по возрастанию дисперсии
    return sorted(variances, key=lambda x: x[1])

# === Основной блок программы ===
if __name__ == "__main__":
    # Пример строки для анализа
    text = "example text for frequency difference"
    
    # Пример частот алфавита для Задачи 3
    alphabet_freq = {'e': 0.12702, 'x': 0.00150, 'a': 0.08167, 'm': 0.02406, 'p': 0.01929}  # и т.д.
    
    # Задача 3
    print("=== Задача 3 ===")
    freq_diff_result = frequency_difference(text, alphabet_freq)
    print("Разница частот:", freq_diff_result)
    
    # Задача 5
    print("\n=== Задача 5 ===")
    most_common_char, quad_dev = quadratic_deviation(text)
    print(f"Частый символ: '{most_common_char}', квадратичное отклонение: {quad_dev}")
    
    # Задача 8
    print("\n=== Задача 8 ===")
    ascii_deviation_result = quadratic_ascii_deviation(text)
    print("ASCII отклонения пар:", ascii_deviation_result)
    
    # Задача 9
    print("\n=== Задача 9 ===")
    triple_variance_result = ascii_triple_variance(text)
    print("Отклонения дисперсий троек символов:", triple_variance_result)

Теоретическая часть
Частота символов в тексте: Частота символа в тексте — это отношение количества встреч данного символа к общему числу символов в тексте. Например, если символ 'e' встречается 5 раз в тексте из 100 символов, его частота равна 5/100 = 0.05. Эта информация помогает нам понять, какие символы наиболее часто встречаются в тексте и сравнить их с частотами символов в языке в целом.

Квадратичное отклонение: Квадратичное отклонение (англ. quadratic deviation) — это показатель разброса значений относительно среднего значения. Оно рассчитывается как квадрат разности между фактической частотой и некоторой эталонной частотой. Квадратичное отклонение помогает понять, насколько сильно фактические частоты отличаются от ожидаемых.

Дисперсия: Дисперсия показывает средний квадрат отклонений значений от их среднего. Используется для оценки изменчивости данных. В нашем случае — для анализа разброса ASCII-кодов символов.

ASCII-коды символов: ASCII — это стандартная таблица кодировки символов, где каждому символу соответствует уникальный числовой код. Например, 'A' имеет код 65, 'B' — 66 и так далее. При работе с текстом на Python можно получить ASCII-код символа с помощью функции ord(), а сам символ из ASCII-кода — с помощью chr().

Частоты букв алфавита берутся из статистических исследований текстов, написанных на определенном языке. Обычно частоты рассчитываются на основе большого количества текстов и представляют собой вероятности появления каждой буквы в среднем тексте. Например, для английского языка эти частоты определены на основе анализа книг, статей, писем и других текстов. Такие данные помогают понять, какие символы наиболее характерны для определенного языка и как часто они встречаются.

Откуда берутся частоты:
Анализ больших корпусов текстов: Частоты букв рассчитываются путем анализа корпусов текстов — больших коллекций, содержащих миллионы или даже миллиарды слов. Для английского языка используется, например, корпус Brown Corpus или British National Corpus.

Частоты букв в английском языке: Частоты символов зависят от типа текста (например, научный, художественный и т.д.), но в среднем для английского языка частоты букв таковы:

e — 12.702%
t — 9.056%
a — 8.167%
o — 7.507%
i — 6.966%
n — 6.749%
s — 6.327%
h — 6.094%
и так далее.
Эти значения показывают процентное отношение появления букв в стандартном тексте и могут варьироваться в зависимости от источника и типа текста.

Где брать частоты для других языков:
Если вам нужно найти частоты для других языков, таких как русский или немецкий, есть несколько источников:

Онлайн-корпусы:

Russian National Corpus для русского языка.
German Reference Corpus для немецкого.
Исследовательские работы:

Частоты символов приводятся в академических и научных публикациях, особенно в области лингвистики и криптографии.
Генерация частот самостоятельно: Вы можете самостоятельно рассчитать частоты символов для конкретного текста. Для этого нужно:

Подсчитать количество каждого символа.
Разделить количество символов на общее число символов в тексте.
Преобразовать значения в проценты или вероятности.

